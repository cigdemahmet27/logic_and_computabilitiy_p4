"""

  Goal: Handle all communication with the external Inference Engine (Project #3) and the file system. The project relies on passing text files back and forth.



What you must do:



write_trigger(literal, decision_level):



Create a text file named (e.g., BCP_TRIGGER_INPUT.txt).



Write exactly two lines: TRIGGER_LITERAL: <value> and DL: <value>.



read_bcp_output():



Open the output file generated by the Inference Engine.





Parse Status: Extract lines starting with STATUS:, DL:, and CONFLICT_ID: .





Parse Variables: Read the CURRENT VARIABLE STATE section. You need to store which variables are TRUE, FALSE, or UNASSIGNED into a Python dictionary or list. This is crucial for your Heuristic to know which variables are left to pick.



append_to_master_trace(content):



Read the BCP EXECUTION LOG section from the output.



Append this content to your final MASTER_TRACE.txt file. This is required for Project #5.



"""





import os

import config



class IOManager:

    def __init__(self):

        # Ensure the master trace file is clean/empty when we start

        if os.path.exists(config.MASTER_TRACE_FILE):

            os.remove(config.MASTER_TRACE_FILE)



    def write_trigger(self, literal, decision_level):

        """

        Creates the BCP TRIGGER INPUT file as specified in the PDF.

        Format:

        TRIGGER_LITERAL: <value>

        DL: <value>

        """

        content = f"TRIGGER_LITERAL: {literal}\nDL: {decision_level}\n"

        

        with open(config.TRIGGER_INPUT_FILE, "w") as f:

            f.write(content)



    def read_bcp_output(self):

        """

        Parses the output from the Inference Engine.

        Returns a dictionary with status and variable states.

        """

        result = {

            "status": None,

            "conflict_id": None,

            "unassigned_vars": [], # List of integers

            "assignments": {},      # Dict {var: True/False}

            "full_log": ""          # Raw text for the master trace

        }



        if not os.path.exists(config.BCP_OUTPUT_FILE):

            raise FileNotFoundError(f"Cannot find {config.BCP_OUTPUT_FILE}. Did the engine run?")



        with open(config.BCP_OUTPUT_FILE, "r") as f:

            lines = f.readlines()

            result["full_log"] = "".join(lines) # Save everything for the trace



            # -- PARSING LOGIC --

            parsing_vars = False

            current_var = None



            for line in lines:

                line = line.strip()

                

                # 1. Capture Status [cite: 76-78]

                if line.startswith("STATUS:"):

                    result["status"] = line.split(":")[1].strip()

                elif line.startswith("CONFLICT_ID:"):

                    val = line.split(":")[1].strip()

                    result["conflict_id"] = val if val != "None" else None



                # 2. Capture Variable States [cite: 101]

                elif line == "--- CURRENT VARIABLE STATE ---":

                    parsing_vars = True

                    continue

                

                if parsing_vars and line:

                    if "|" in line:

                        parts = line.split("|")

                        if len(parts) == 2:

                            var_str = parts[0].strip()

                            state = parts[1].strip()

                            if var_str.isdigit():

                                var = int(var_str)

                                if state == "UNASSIGNED":

                                    result["unassigned_vars"].append(var)

                                elif state == "TRUE":

                                    result["assignments"][var] = True

                                elif state == "FALSE":

                                    result["assignments"][var] = False



        return result



    def append_to_trace(self, content):

        """

        Appends the log content to the Master Trace file for Project #5.

        """

        with open(config.MASTER_TRACE_FILE, "a") as f:

            f.write(content + "\n")

